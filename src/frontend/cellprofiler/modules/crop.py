"""
Crop
====

**Crop** crops or masks an image.

This module crops images into a rectangle, ellipse, an arbitrary shape
provided by you, the shape of object(s) identified by an **Identify**
module, or a shape created using a previous **Crop** module in the
pipeline.

Keep in mind that cropping changes the size of your images, which may
have unexpected consequences. For example, identifying objects in a
cropped image and then trying to measure their intensity in the
*original* image will not work because the two images are not the same
size.

|

============ ============ ===============
Supports 2D? Supports 3D? Respects masks?
============ ============ ===============
YES          NO           YES
============ ============ ===============

Measurements made by this module
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

-  *AreaRetainedAfterCropping:* The area of the image left after
   cropping.
-  *OriginalImageArea:* The area of the original input image.

*Special note on saving images:* You can save the cropping shape that
you have defined in this module (e.g., an ellipse you drew) so that you
can use the *Image* option in future analyses. To do this, save either
the mask or cropping in **SaveImages**. See the **SaveImages** module
help for more information on saving cropping shapes.
"""

import logging
import centrosome.filter
import matplotlib.axes
import matplotlib.cm
import matplotlib.figure
import matplotlib.patches
import numpy
from cellprofiler_core.image import Image
from cellprofiler_core.module import Module
from cellprofiler_core.preferences import get_primary_outline_color
from cellprofiler_core.setting import Coordinates
from cellprofiler_core.setting.choice import Choice
from cellprofiler_core.setting.range import IntegerOrUnboundedRange
from cellprofiler_core.setting.subscriber import CropImageSubscriber
from cellprofiler_core.setting.subscriber import ImageSubscriber
from cellprofiler_core.setting.subscriber import LabelSubscriber
from cellprofiler_core.setting.text import CropImageName
from cellprofiler_core.setting.text import Integer
from cellprofiler_library.functions.image_processing import get_ellipse_cropping, get_rectangle_cropping
from cellprofiler_library.modules._crop import crop, get_measurements
from cellprofiler_library.opts.crop import RemovalMethod, Measurement, Shape, CroppingMethod, CroppingPattern, Limits, Ellipse, Rectangle
LOGGER = logging.getLogger(__name__)


OFF_IMAGE_NAME = 0
OFF_CROPPED_IMAGE_NAME = 1
OFF_SHAPE = 2
OFF_CROP_METHOD = 3
OFF_INDIVIDUAL_OR_ONCE = 4
OFF_HORIZONTAL_LIMITS = 5
OFF_VERTICAL_LIMITS = 6
OFF_CENTER = 7
OFF_X_RADIUS = 8
OFF_Y_RADIUS = 9
OFF_REMOVE_ROWS_AND_COLUMNS = 11
OFF_IMAGE_MASK_SOURCE = 12
OFF_CROPPING_MASK_SOURCE = 13

D_FIRST_IMAGE_SET = "FirstImageSet"
D_FIRST_CROPPING = "FirstCropping"
D_FIRST_CROPPING_MASK = "FirstCroppingMask"


class Crop(Module):
    module_name = "Crop"
    variable_revision_number = 3
    category = "Image Processing"

    def create_settings(self):
        self.image_name = ImageSubscriber(
            text="Select the input image",
            value="None",
            doc="Choose the image to be cropped.",
        )

        self.cropped_image_name = CropImageName(
            text="Name the output image",
            value="CropBlue",
            doc="Enter the name to be given to cropped image.",
        )

        self.shape = Choice(
            text="Select the cropping shape",
            choices=[Shape.RECTANGLE.value, Shape.ELLIPSE.value, Shape.IMAGE.value, Shape.OBJECTS.value, Shape.CROPPING.value],
            value=Shape.RECTANGLE.value,
            doc="""\
Choose the shape into which you would like to crop:

-  *{SH_RECTANGLE}:* Self-explanatory.
-  *{SH_ELLIPSE}:* Self-explanatory.
-  *{SH_IMAGE}:* Cropping will occur based on a binary image you
   specify. A choice box with available images will appear from which
   you can select an image. To crop into an arbitrary shape that you
   define, choose *{SH_IMAGE}* and use a black and white image that you
   have already prepared from a file.
   If you have created this image in a program such as Photoshop,
   this binary image should contain only the values 0 and 255, with
   zeros (black) for the parts you want to remove and 255 (white) for
   the parts you want to retain. Alternately, you may have previously
   generated a binary image using this module (e.g., using the
   *{SH_ELLIPSE}* option) and saved it using the **SaveImages**
   module.
   In any case, the image must be exactly the same starting size as your
   image and should contain a contiguous block of white pixels, because
   the cropping module may remove rows and columns that are completely
   blank.
-  *{SH_OBJECTS}:* Crop based on labeled objects identified by a
   previous **Identify** module.
-  *{SH_CROPPING}:* The cropping generated by a previous cropping
   module. You will be able to select images that were generated by
   previous **Crop** modules. This **Crop** module will use the same
   cropping that was used to generate whichever image you choose.
""".format(
                **{
                    "SH_RECTANGLE": Shape.RECTANGLE.value,
                    "SH_ELLIPSE": Shape.ELLIPSE.value,
                    "SH_IMAGE": Shape.IMAGE.value,
                    "SH_OBJECTS": Shape.OBJECTS.value,
                    "SH_CROPPING": Shape.CROPPING.value,
                }
            ),
        )

        self.crop_method = Choice(
            text="Select the cropping method",
            choices=[CroppingMethod.COORDINATES.value, CroppingMethod.MOUSE.value],
            value=CroppingMethod.COORDINATES.value,
            doc="""\
Choose whether you would like to crop by typing in pixel coordinates or
clicking with the mouse.

-  *{CM_COORDINATES}:* For *{SH_ELLIPSE}*, you will be asked to
   enter the geometric parameters of the ellipse. For
   *{SH_RECTANGLE}*, you will be asked to specify the coordinates of
   the corners.
-  *{CM_MOUSE}:* For *{SH_ELLIPSE}*, you will be asked to click
   five or more points to define an ellipse around the part of the image
   you want to analyze. Keep in mind that the more points you click, the
   longer it will take to calculate the ellipse shape. For
   *{SH_RECTANGLE}*, you can click as many points as you like that
   are in the interior of the region you wish to retain.
""".format(
                **{
                    "CM_COORDINATES": CroppingMethod.COORDINATES.value,
                    "SH_ELLIPSE": Shape.ELLIPSE.value,
                    "SH_RECTANGLE": Shape.RECTANGLE.value,
                    "CM_MOUSE": CroppingMethod.MOUSE.value,
                }
            ),
        )

        self.individual_or_once = Choice(
            text="Apply which cycle's cropping pattern?",
            choices=[CroppingPattern.INDIVIDUALLY.value, CroppingPattern.FIRST.value],
            value=CroppingPattern.INDIVIDUALLY.value,
            doc="""\
Specify how a given cropping pattern should be applied to other image cycles:

-  *{IO_FIRST}:* The cropping pattern from the first image cycle is
   applied to all subsequent cyles. This is useful if the first image is
   intended to function as a template in some fashion.
-  *{IO_INDIVIDUALLY}:* Every image cycle is cropped individually.
""".format(
                **{"IO_FIRST": CroppingPattern.FIRST.value, "IO_INDIVIDUALLY": CroppingPattern.INDIVIDUALLY.value}
            ),
        )

        self.horizontal_limits = IntegerOrUnboundedRange(
            text="Left and right rectangle positions",
            minval=0,
            doc="""\
*(Used only if "{SH_RECTANGLE}" selected as cropping shape, or if using Plate Fix)*

Specify the left and right positions for the bounding rectangle by selecting one of the following:

-  *{ABSOLUTE}:* Specify these values as absolute pixel coordinates in
   the original image. For instance, you might enter “25”, “225”, and
   “Absolute” to create a 200×200 pixel image that is 25 pixels from the
   top-left corner.
-  *{FROM_EDGE}:* Specify the position relative to the image edge.
   For instance, you might enter “25”, “25”, and “Edge” to crop 25
   pixels from both the left and right edges of the image, irrespective
   of the image’s original size.
""".format(
                **{
                    "SH_RECTANGLE": Shape.RECTANGLE.value,
                    "ABSOLUTE": Limits.ABSOLUTE.value,
                    "FROM_EDGE": Limits.FROM_EDGE.value,
                }
            ),
        )

        self.vertical_limits = IntegerOrUnboundedRange(
            text="Top and bottom rectangle positions",
            minval=0,
            doc="""\
*(Used only if "{SH_RECTANGLE}" selected as cropping shape, or if using Plate Fix)*

Specify the top and bottom positions for the bounding rectangle by selecting one of the following:

-  *{ABSOLUTE}:* Specify these values as absolute pixel coordinates.
   For instance, you might enter “25”, “225”, and “Absolute” to create a
   200×200 pixel image that’s 25 pixels from the top-left corner.
-  *{FROM_EDGE}:* Specify position relative to the image edge. For
   instance, you might enter “25”, “25”, and “Edge” to crop 25 pixels
   from the edges of your images irrespective of their size.
""".format(
                **{
                    "SH_RECTANGLE": Shape.RECTANGLE.value,
                    "ABSOLUTE": Limits.ABSOLUTE.value,
                    "FROM_EDGE": Limits.FROM_EDGE.value,
                }
            ),
        )

        self.ellipse_center = Coordinates(
            text="Coordinates of ellipse center",
            value=(500, 500),
            doc="""\
*(Used only if "{SH_ELLIPSE}" selected as cropping shape)*

Specify the center pixel position of the ellipse.
""".format(
                **{"SH_ELLIPSE": Shape.ELLIPSE.value}
            ),
        )

        self.ellipse_x_radius = Integer(
            text="Ellipse radius, X direction",
            value=400,
            doc="""\
*(Used only if "{SH_ELLIPSE}" selected as cropping shape)*

Specify the radius of the ellipse in the X direction.
""".format(
                **{"SH_ELLIPSE": Shape.ELLIPSE.value}
            ),
        )

        self.ellipse_y_radius = Integer(
            text="Ellipse radius, Y direction",
            value=200,
            doc="""\
*(Used only if "{SH_ELLIPSE}" selected as cropping shape)*

Specify the radius of the ellipse in the Y direction.
""".format(
                **{"SH_ELLIPSE": Shape.ELLIPSE.value}
            ),
        )

        self.image_mask_source = ImageSubscriber(
            text="Select the masking image",
            value="None",
            doc="""\
*(Used only if "{SH_IMAGE}" selected as cropping shape)*

Select the image to be use as a cropping mask.
""".format(
                **{"SH_IMAGE": Shape.IMAGE.value}
            ),
        )

        self.cropping_mask_source = CropImageSubscriber(
            text="Select the image with a cropping mask",
            value="None",
            doc="""\
*(Used only if "{SH_CROPPING}" selected as cropping shape)*

Select the image associated with the cropping mask that you want to use.
""".format(
                **{"SH_CROPPING": Shape.CROPPING.value}
            ),
        )

        self.objects_source = LabelSubscriber(
            text="Select the objects",
            value="None",
            doc="""\
*(Used only if "{SH_OBJECTS}" selected as cropping shape)*

Select the objects that are to be used as a cropping mask.
""".format(
                **{"SH_OBJECTS": Shape.OBJECTS.value}
            ),
        )

        self.remove_rows_and_columns = Choice(
            text="Remove empty rows and columns?",
            choices=[RemovalMethod.NO.value, RemovalMethod.EDGES.value, RemovalMethod.ALL.value],
            value=RemovalMethod.ALL.value,
            doc="""\
Use this option to choose whether to remove rows and columns that lack
objects:

-  *{RM_NO}:* Leave the image the same size. The cropped areas will
   be set to zeroes, and will appear as black.
-  *{RM_EDGES}:* Crop the image so that its top, bottom, left and
   right are at the first non-blank pixel for that edge.
-  *{RM_ALL}:* Remove any row or column of all-blank pixels, even
   from the internal portion of the image.
""".format(
                **{"RM_NO": RemovalMethod.NO.value, "RM_EDGES": RemovalMethod.EDGES.value, "RM_ALL": RemovalMethod.ALL.value}
            ),
        )

    def settings(self):
        return [
            self.image_name,
            self.cropped_image_name,
            self.shape,
            self.crop_method,
            self.individual_or_once,
            self.horizontal_limits,
            self.vertical_limits,
            self.ellipse_center,
            self.ellipse_x_radius,
            self.ellipse_y_radius,
            self.remove_rows_and_columns,
            self.image_mask_source,
            self.cropping_mask_source,
            self.objects_source,
        ]

    def visible_settings(self):
        result = [self.image_name, self.cropped_image_name, self.shape]
        if self.shape.value in (Shape.RECTANGLE, Shape.ELLIPSE):
            result += [self.crop_method, self.individual_or_once]
            if self.crop_method.value == CroppingMethod.COORDINATES:
                if self.shape.value == Shape.RECTANGLE:
                    result += [self.horizontal_limits, self.vertical_limits]
                elif self.shape.value == Shape.ELLIPSE:
                    result += [
                        self.ellipse_center,
                        self.ellipse_x_radius,
                        self.ellipse_y_radius,
                    ]
        elif self.shape.value == Shape.IMAGE:
            result += [self.image_mask_source]
        elif self.shape.value == Shape.CROPPING:
            result.append(self.cropping_mask_source)
        elif self.shape.value == Shape.OBJECTS:
            result.append(self.objects_source)
        else:
            raise NotImplementedError("Unimplemented shape type: %s" % self.shape.value)
        result += [self.remove_rows_and_columns]
        return result

    def run(self, workspace):
        first_image_set = (
            workspace.measurements.get_current_image_measurement("Group_Index") == 1
        )
        image_set_list = workspace.image_set_list
        cache_dict = self.get_dictionary(image_set_list)
        orig_image = workspace.image_set.get_image(self.image_name.value)
        recalculate_flag = (
            self.shape.value not in (Shape.ELLIPSE, Shape.RECTANGLE)
            or self.individual_or_once.value == CroppingPattern.INDIVIDUALLY
            or first_image_set
            or workspace.pipeline.test_mode
        )
        save_flag = self.individual_or_once.value == CroppingPattern.FIRST and first_image_set
        if not recalculate_flag:
            if cache_dict[D_FIRST_CROPPING].shape != orig_image.pixel_data.shape[:2]:
                recalculate_flag = True
                LOGGER.warning(
                    """Image, "%s", size changed from %s to %s during cycle %d, recalculating""",
                    self.image_name.value,
                    str(cache_dict[D_FIRST_CROPPING].shape),
                    str(orig_image.pixel_data.shape[:2]),
                    workspace.image_set.image_number,
                )
        mask = None  # calculate the mask after cropping unless set below
        cropping = None
        masking_objects = None
        if not recalculate_flag:
            cropping = cache_dict[D_FIRST_CROPPING]
            mask = cache_dict[D_FIRST_CROPPING_MASK]
        elif self.shape.value == Shape.CROPPING:
            cropping_image = workspace.image_set.get_image(
                self.cropping_mask_source.value
            )
            cropping = cropping_image.crop_mask
        elif self.shape.value == Shape.IMAGE:
            source_image = workspace.image_set.get_image(
                self.image_mask_source.value
            ).pixel_data

            cropping = source_image > 0
        elif self.shape.value == Shape.OBJECTS:
            masking_objects = workspace.get_objects(self.objects_source.value)
            cropping = masking_objects.segmented > 0
        elif self.crop_method.value == CroppingMethod.MOUSE:
            cropping = self.ui_crop(workspace, orig_image)
        elif self.shape.value == Shape.ELLIPSE:
            cache_dict[Shape.ELLIPSE] = {
                Ellipse.XCENTER: self.ellipse_center.x,   
                Ellipse.YCENTER: self.ellipse_center.y,
                Ellipse.XRADIUS: self.ellipse_x_radius.value,
                Ellipse.YRADIUS: self.ellipse_y_radius.value,
            }
        
            cropping = get_ellipse_cropping(
                orig_image.pixel_data, 
                (self.ellipse_center.x, self.ellipse_center.y), 
                (self.ellipse_x_radius.value, self.ellipse_y_radius.value)
                )


        elif self.shape.value == Shape.RECTANGLE:
            h_min = self.horizontal_limits.min if not self.horizontal_limits.unbounded_min else None
            h_max = self.horizontal_limits.max if not self.horizontal_limits.unbounded_max else None
            v_min = self.vertical_limits.min if not self.vertical_limits.unbounded_min else None
            v_max = self.vertical_limits.max if not self.vertical_limits.unbounded_max else None

            cropping = get_rectangle_cropping(orig_image.pixel_data, (h_min, h_max, v_min, v_max), validate_boundaries=True)
        else:
            raise NotImplementedError(f"Cropping shape {self.shape.value} or crop method {self.crop_method} not supported.")
        
        assert(cropping is not None)
        assert(cropping.dtype == bool)
        
        cropped_pixel_data, mask, image_mask = crop(orig_image.pixel_data, cropping, mask, orig_image.mask, self.remove_rows_and_columns.value)
            

        if self.shape.value == Shape.OBJECTS:
            # Special handling for objects - masked objects instead of
            # mask and crop mask
            output_image = Image(
                image=cropped_pixel_data,
                masking_objects=masking_objects,
                parent_image=orig_image,
            )
        else:
            output_image = Image(
                image=cropped_pixel_data,
                mask=image_mask,
                parent_image=orig_image,
                crop_mask=cropping,
            )
        #
        # Display the image
        #
        if self.show_window:
            workspace.display_data.orig_image_pixel_data = orig_image.pixel_data
            workspace.display_data.cropped_pixel_data = cropped_pixel_data
            workspace.display_data.image_set_number = (
                workspace.measurements.image_set_number
            )

        if save_flag:
            cache_dict[D_FIRST_CROPPING_MASK] = mask
            cache_dict[D_FIRST_CROPPING] = cropping
        #
        # Save the image / cropping / mask
        #
        workspace.image_set.add(self.cropped_image_name.value, output_image)
        #
        # Save the old and new image sizes
        #
        m = workspace.measurements
        for measurement in get_measurements(cropping, orig_image.pixel_data, self.cropped_image_name.value):
            m.add_measurement("Image", measurement[1], numpy.array([measurement[2]]))


    def display(self, workspace, figure):
        orig_image_pixel_data = workspace.display_data.orig_image_pixel_data
        cropped_pixel_data = workspace.display_data.cropped_pixel_data
        figure.set_subplots((2, 1))

        title = "Original: %s, cycle # %d" % (
            self.image_name.value,
            workspace.display_data.image_set_number,
        )
        figure.subplot_imshow_grayscale(0, 0, orig_image_pixel_data, title)
        figure.subplot_imshow_bw(
            1, 0, cropped_pixel_data, self.cropped_image_name.value,
        )

    def get_measurement_columns(self, pipeline):
        """Return information on the measurements made during cropping"""
        return [
            ("Image", x % self.cropped_image_name.value, "integer",)
            for x in (Measurement.AREA_RETAINED, Measurement.ORIGINAL_AREA)
        ]

    def ui_crop(self, workspace, orig_image):
        """Crop into a rectangle or ellipse, guided by UI"""
        cache_dict = self.get_dictionary(workspace.image_set_list)
        if (self.shape.value not in cache_dict) or self.individual_or_once.value == CroppingPattern.INDIVIDUALLY:
            cache_dict[self.shape.value] = workspace.interaction_request(
                self, cache_dict.get(self.shape.value, None), orig_image.pixel_data
            )
        if self.shape.value == Shape.ELLIPSE:
            center = cache_dict[Shape.ELLIPSE][Ellipse.XCENTER], cache_dict[Shape.ELLIPSE][Ellipse.YCENTER]
            radius = cache_dict[Shape.ELLIPSE][Ellipse.XRADIUS], cache_dict[Shape.ELLIPSE][Ellipse.YRADIUS]   
            return get_ellipse_cropping(orig_image.pixel_data, center, radius)
        else:
            bounding_box = (
                int(numpy.round(cache_dict[Shape.RECTANGLE][Rectangle.LEFT])),
                int(numpy.round(cache_dict[Shape.RECTANGLE][Rectangle.RIGHT])),
                int(numpy.round(cache_dict[Shape.RECTANGLE][Rectangle.TOP])),
                int(numpy.round(cache_dict[Shape.RECTANGLE][Rectangle.BOTTOM])),
            )
            return get_rectangle_cropping(orig_image.pixel_data, bounding_box, validate_boundaries=True)

    def handle_interaction(self, current_shape, orig_image):
        from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg
        import wx

        """Show the cropping user interface"""
        pixel_data = centrosome.filter.stretch(orig_image)
        #
        # Create the UI - a dialog with a figure inside
        #
        style = wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER
        dialog_box = wx.Dialog(
            wx.GetApp().TopWindow,
            -1,
            "Select the cropping region",
            size=(640, 480),
            style=style,
        )
        sizer = wx.BoxSizer(wx.VERTICAL)
        figure = matplotlib.figure.Figure()
        panel = FigureCanvasWxAgg(dialog_box, -1, figure)
        sizer.Add(panel, 1, wx.EXPAND)
        btn_sizer = wx.StdDialogButtonSizer()
        btn_sizer.AddButton(wx.Button(dialog_box, wx.ID_OK))
        btn_sizer.AddButton(wx.Button(dialog_box, wx.ID_CANCEL))
        btn_sizer.Realize()
        sizer.Add(btn_sizer, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, 5)
        dialog_box.SetSizer(sizer)
        dialog_box.Size = dialog_box.BestSize
        dialog_box.Layout()

        axes = figure.add_subplot(1, 1, 1)
        assert isinstance(axes, matplotlib.axes.Axes)
        if pixel_data.ndim == 2:
            axes.imshow(pixel_data, matplotlib.cm.Greys_r, origin="upper")
        else:
            axes.imshow(pixel_data, origin="upper")
        # t = axes.transData.inverted()
        current_handle = [None]

        def data_xy(mouse_event):
            """Return the mouse event's x & y converted into data-relative coords"""
            x = mouse_event.xdata
            y = mouse_event.ydata
            return x, y

        class Handle(matplotlib.patches.Rectangle):
            dm = max((10, min(pixel_data.shape) / 50))
            height, width = (dm, dm)

            def __init__(self, x, y, on_move):
                x = max(0, min(x, pixel_data.shape[1]))
                y = max(0, min(y, pixel_data.shape[0]))
                self.__selected = False
                self.__color = get_primary_outline_color()
                self.__color = numpy.hstack(self.__color).astype(float) / 255.0
                self.__on_move = on_move
                super(Handle, self).__init__(
                    (x - self.width / 2, y - self.height / 2),
                    self.width,
                    self.height,
                    edgecolor=self.__color,
                    facecolor="none",
                )
                self.set_picker(True)

            def move(self, x, y):
                self.set_xy((x - self.width / 2, y - self.height / 2))
                self.__on_move(x, y)

            def select(self, on):
                self.__selected = on
                if on:
                    current_handle[0] = self
                    self.set_facecolor(self.__color)

                else:
                    self.set_facecolor("none")
                    if current_handle[0] == self:
                        current_handle[0] = None
                figure.canvas.draw()
                dialog_box.Update()

            @property
            def is_selected(self):
                return self.__selected

            @property
            def center_x(self):
                """The handle's notion of its x coordinate"""
                return self.get_x() + self.get_width() / 2

            @property
            def center_y(self):
                """The handle's notion of its y coordinate"""
                return self.get_y() + self.get_height() / 2

            def handle_pick(self, event):
                mouse_event = event.mouseevent
                x, y = data_xy(mouse_event)
                if mouse_event.button == 1:
                    self.select(True)
                    self.orig_x = self.center_x
                    self.orig_y = self.center_y
                    self.first_x = x
                    self.first_y = y

            def handle_mouse_move_event(self, event):
                x, y = data_xy(event)
                if x is None or y is None:
                    return
                x = x - self.first_x + self.orig_x
                y = y - self.first_y + self.orig_y
                if x < 0:
                    x = 0
                if x >= pixel_data.shape[1]:
                    x = pixel_data.shape[1] - 1
                if y < 0:
                    y = 0
                if y >= pixel_data.shape[0]:
                    y = pixel_data.shape[0] - 1
                self.move(x, y)

        class CropRectangle(object):
            def __init__(self, top_left, bottom_right):
                self.__left, self.__top = top_left
                self.__right, self.__bottom = bottom_right
                color = get_primary_outline_color()
                color = numpy.hstack(color).astype(float) / 255.0
                self.rectangle = matplotlib.patches.Rectangle(
                    (min(self.__left, self.__right), min(self.__bottom, self.__top)),
                    abs(self.__right - self.__left),
                    abs(self.__top - self.__bottom),
                    edgecolor=color,
                    facecolor="none",
                )
                self.top_left_handle = Handle(
                    top_left[0], top_left[1], self.handle_top_left
                )
                self.bottom_right_handle = Handle(
                    bottom_right[0], bottom_right[1], self.handle_bottom_right
                )

            def handle_top_left(self, x, y):
                self.__left = x
                self.__top = y
                self.__reshape()

            def handle_bottom_right(self, x, y):
                self.__right = x
                self.__bottom = y
                self.__reshape()

            def __reshape(self):
                self.rectangle.set_xy(
                    (min(self.__left, self.__right), min(self.__bottom, self.__top))
                )
                self.rectangle.set_width(abs(self.__right - self.__left))
                self.rectangle.set_height(abs(self.__bottom - self.__top))
                self.rectangle.figure.canvas.draw()
                dialog_box.Update()

            @property
            def patches(self):
                return [self.rectangle, self.top_left_handle, self.bottom_right_handle]

            @property
            def handles(self):
                return [self.top_left_handle, self.bottom_right_handle]

            @property
            def left(self):
                return min(self.__left, self.__right)

            @property
            def right(self):
                return max(self.__left, self.__right)

            @property
            def top(self):
                return min(self.__top, self.__bottom)

            @property
            def bottom(self):
                return max(self.__top, self.__bottom)

        class CropEllipse(object):
            def __init__(self, center, radius):
                """Draw an ellipse with control points at the ellipse center and
                a given x and y radius"""
                self.center_x, self.center_y = center
                self.radius_x = self.center_x + radius[0] / 2
                self.radius_y = self.center_y + radius[1] / 2
                color = get_primary_outline_color()
                color = numpy.hstack(color).astype(float) / 255.0
                self.ellipse = matplotlib.patches.Ellipse(
                    center, self.width, self.height, edgecolor=color, facecolor="none"
                )
                self.center_handle = Handle(
                    self.center_x, self.center_y, self.move_center
                )
                self.radius_handle = Handle(
                    self.radius_x, self.radius_y, self.move_radius
                )

            def move_center(self, x, y):
                self.center_x = x
                self.center_y = y
                self.redraw()

            def move_radius(self, x, y):
                self.radius_x = x
                self.radius_y = y
                self.redraw()

            @property
            def width(self):
                return abs(self.center_x - self.radius_x) * 4

            @property
            def height(self):
                return abs(self.center_y - self.radius_y) * 4

            def redraw(self):
                self.ellipse.center = (self.center_x, self.center_y)
                self.ellipse.width = self.width
                self.ellipse.height = self.height
                self.ellipse.figure.canvas.draw()
                dialog_box.Update()

            @property
            def patches(self):
                return [self.ellipse, self.center_handle, self.radius_handle]

            @property
            def handles(self):
                return [self.center_handle, self.radius_handle]

        if self.shape.value == Shape.ELLIPSE:
            if current_shape is None:
                current_shape = {
                    Ellipse.XCENTER: pixel_data.shape[1] / 2,
                    Ellipse.YCENTER: pixel_data.shape[0] / 2,
                    Ellipse.XRADIUS: pixel_data.shape[1] / 2,
                    Ellipse.YRADIUS: pixel_data.shape[0] / 2,
                }
            ellipse = current_shape
            shape = CropEllipse(
                (ellipse[Ellipse.XCENTER], ellipse[Ellipse.YCENTER]),
                (ellipse[Ellipse.XRADIUS], ellipse[Ellipse.YRADIUS]),
            )
        else:
            if current_shape is None:
                current_shape = {
                    Rectangle.LEFT: pixel_data.shape[1] / 4,
                    Rectangle.TOP: pixel_data.shape[0] / 4,
                    Rectangle.RIGHT: pixel_data.shape[1] * 3 / 4,
                    Rectangle.BOTTOM: pixel_data.shape[0] * 3 / 4,
                }
            rectangle = current_shape
            shape = CropRectangle(
                (rectangle[Rectangle.LEFT], rectangle[Rectangle.TOP]),
                (rectangle[Rectangle.RIGHT], rectangle[Rectangle.BOTTOM]),
            )
        for patch in shape.patches:
            axes.add_artist(patch)

        def on_mouse_down_event(event):
            axes.pick(event)

        def on_mouse_move_event(event):
            if current_handle[0] is not None:
                current_handle[0].handle_mouse_move_event(event)

        def on_mouse_up_event(event):
            if current_handle[0] is not None:
                current_handle[0].select(False)

        def on_pick_event(event):
            for h in shape.handles:
                if id(h) == id(event.artist):
                    h.handle_pick(event)

        figure.canvas.mpl_connect("button_press_event", on_mouse_down_event)
        figure.canvas.mpl_connect("button_release_event", on_mouse_up_event)
        figure.canvas.mpl_connect("motion_notify_event", on_mouse_move_event)
        figure.canvas.mpl_connect("pick_event", on_pick_event)

        try:
            if dialog_box.ShowModal() != wx.ID_OK:
                raise ValueError("Cancelled by user")
        finally:
            dialog_box.Destroy()
        if self.shape.value == Shape.RECTANGLE:
            return {
                Rectangle.LEFT: shape.left,
                Rectangle.TOP: shape.top,
                Rectangle.RIGHT: shape.right,
                Rectangle.BOTTOM: shape.bottom,
            }
        else:
            return {
                Ellipse.XCENTER: shape.center_x,
                Ellipse.YCENTER: shape.center_y,
                Ellipse.XRADIUS: shape.width / 2,
                Ellipse.YRADIUS: shape.height / 2,
            }


    def upgrade_settings(self, setting_values, variable_revision_number, module_name):
        if variable_revision_number == 1:
            # Added ability to crop objects
            new_setting_values = list(setting_values)
            new_setting_values.append("None")
            variable_revision_number = 2

        if variable_revision_number == 2:
            # minor - "Cropping" changed to "Previous cropping"
            setting_values = list(setting_values)
            if setting_values[OFF_SHAPE] == "Cropping":
                setting_values[OFF_SHAPE] = Shape.CROPPING
            #
            # Individually changed to "every"
            #
            if setting_values[OFF_INDIVIDUAL_OR_ONCE] == "Individually":
                setting_values[OFF_INDIVIDUAL_OR_ONCE] = CroppingPattern.INDIVIDUALLY

            setting_values = setting_values[:10] + setting_values[11:]

            variable_revision_number = 3

        return setting_values, variable_revision_number
